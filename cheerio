#include <stdio.h>
#include <Windows.h>
#include <stdlib.h>
#include <stdbool.h>
#define MAX 20
#define MAX_POINTS 50

// quick array
int sorted[20];

// queue max 20
int queue[MAX];
int front, rear = 0;

// dfs
_Bool connection[50][50] = { 0, };
_Bool visit[50];
int np, nw;
//bfs
_Bool bfsConnection[MAX_POINTS][MAX_POINTS] = { 0 };
_Bool bfsVisit[MAX_POINTS];
int bfsNp, bfsNw;

// pixcell move
void gotoxy(int x, int y) {
    COORD pos = { x,y };
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
}
// array swap
void swap(int* x, int* y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

//버블
void bubble_sort(int* arr, int n) {
    for (int i = 0; i < n - 1; i++) {
        printf("%d회차 정렬:\t", i);
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(&arr[j], &arr[j + 1]);
            }
        }
        for (int k = 0; k < n; k++) {
            printf("%d ", arr[k]);
        }
        printf("\n");
    }
    printf("오름차순으로 정리된 배열입니다.");
    printf("\n"); // 정렬 결과를 출력한 후 개행문자를 추가하여 줄을 바꿉니다.
}
//삽입
void insertion_sort(int arr[], int n) {
    int key, j = 0;
    printf("\n");
    for (int i = 0; i < n; i++) {
        printf("%d회차 정렬:\t", i);
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
        for (int k = 0; k < n; k++) {
            printf("%d ", arr[k]);
        }
        printf("\n");
    }
}
//선택
void selection_sort(int arr[], int n) {
    int i, j, min;
    for (i = 0; i < n - 1; i++) {
        min = i;
        printf("%d회차 정렬: \t", i);
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[min]) {
                min = j;
            }
        }
        swap(&arr[min], &arr[i]);
        for (int k = 0; k < n; k++) {
            printf("%d ", arr[k]);
        }
        printf("\n");
    }
}
// 퀵
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}
int partition(int arr[], int left, int right) {
    int pivot = arr[right];
    int i = left - 1;

    for (int j = left; j < right; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[right]);
    return i + 1;
}
void quick_sort(int arr[], int left, int right) {
    printf("\n");
    if (left < right) {
        printf("배열의 끝인 %d을 피벗으로 설정 값이 %d보다 크면 우측, 작으면 좌측 분류 : \n", arr[right], arr[right]);
        int pivot = partition(arr, left, right);
        printArray(arr, right - left + 1);
        printf("\n\n");

        printf("피벗을 기준으로 왼쪽 파티션 오른쪽 파티션 나눠서 다시 퀵 정렬 진행");
        quick_sort(arr, left, pivot - 1);
        quick_sort(arr, pivot + 1, right);
    }
    printf("더 이상 나눌 수 없습니다!\n");
}
//합병
void print_merge(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        if (i < size - 1) {
            printf("%d ", arr[i]);
        }
        else {
            printf("%d ", arr[i]);
        }
    }
    printf("\n");
}
void merge(int arr[], int l, int m, int r) {
    int i = l;
    int j = m + 1;
    int k = l;
    while (i <= m && j <= r) {
        if (arr[i] <= arr[j]) {
            sorted[k++] = arr[i++];
        }
        else {
            sorted[k++] = arr[j++];
        }
    }
    if (i > m) {
        for (; j <= r; j++) {
            sorted[k++] = arr[j];
        }
    }
    else {
        for (; i <= m; i++) {
            sorted[k++] = arr[i];
        }
    }
    for (int i = l; i <= r; i++) {
        arr[i] = sorted[i];
    }
    // Print the current state of the array
    printf("현 배열 상태: ");
    print_merge(arr, r - 1 + 1);
}
void merge_sort(int arr[], int l, int r) {
    if (l < r) {
        int m = (l + r) / 2;
        printf("정렬중: ");
        print_merge(arr + 1, r);

        merge_sort(arr, l, m);
        merge_sort(arr, m + 1, r);

        merge(arr, l, m, r);
    }
}
// 힙
void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    if (largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        heapify(arr, n, largest);
    }
}
void heap_sort(int arr[], int n) {
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    for (int i = n - 1; i > 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        heapify(arr, i, 0);
    }
}
// 기수
int put(int k) {
    if ((rear + 1) % MAX == front) {
        printf("QUEUE OVER FLOW!\n\n");
        return -1;
    }
    else {
        queue[rear] = k;
        rear = ++rear % MAX;
        return 1;
    }
}
int get() {
    int k;
    if (front == rear) {
        printf("QUEUE UNDER FLOW!\n\n");
        return -1;
    }
    else {
        k = queue[front];
        front = ++front % MAX;
        return k;
    }
}
void print_radix(int array[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%-4d", array[i]);
    }
    printf("\n");
}
void radix_sort(int array[], int size) {
    int max = array[0];
    int digit = 0;
    int factor = 1;

    for (int i = 1; i < size; i++) {
        if (max < array[i]) max = array[i];
    }

    for (int i = max; i > 0; i /= 10) {
        digit++;
    }

    for (int i = 0; i < digit; i++) {
        for (int j = 0; j < 10; j++) { // 0~9
            for (int k = 0; k < size; k++) {
                if ((array[k] / factor) % 10 == j) {
                    put(array[k]);
                }
            }
        }

        factor *= 10;

        for (int i = front; i != rear; i++) {
            array[i] = get();
        }

        printf("########### %d ROUND ###########\n", i + 1);
        print_radix(array, size);

        front = rear = 0;
    }
}
// dfs
void dfs(int start) {
    visit[start] = true;
    printf("Visited %d\n", start);
    for (int i = 0; i < np + 1; i++) {
        if (connection[start][i])
            if (!visit[i])
                dfs(i);
    }
    return;
}
//bfs
typedef struct bfsQueueNode {
    int data;
    struct bfsQueueNode* next;
} bfsQueueNode;
typedef struct {
    bfsQueueNode* front;
    bfsQueueNode* rear;
} bfsQueue;
bfsQueue* createBfsQueue() {
    bfsQueue* queue = (bfsQueue*)malloc(sizeof(bfsQueue));
    queue->front = queue->rear = NULL;
    return queue;
}
void bfsEnqueue(bfsQueue* queue, int data) {
    bfsQueueNode* newNode = (bfsQueueNode*)malloc(sizeof(bfsQueueNode));
    newNode->data = data;
    newNode->next = NULL;

    if (queue->rear == NULL) {
        queue->front = queue->rear = newNode;
        return;
    }

    queue->rear->next = newNode;
    queue->rear = newNode;
}
int bfsDequeue(bfsQueue* queue) {
    if (queue->front == NULL) {
        return -1; // Empty queue
    }

    int data = queue->front->data;
    bfsQueueNode* temp = queue->front;

    queue->front = queue->front->next;

    if (queue->front == NULL) {
        queue->rear = NULL;
    }

    free(temp);
    return data;
}
void bfsTraverse(int start) {
    bfsQueue* queue = createBfsQueue();

    bfsVisit[start] = true;
    printf("Visited %d\n", start);
    bfsEnqueue(queue, start);

    while (queue->front != NULL) {
        int current = bfsDequeue(queue);

        for (int i = 0; i < bfsNp + 1; i++) {
            if (bfsConnection[current][i] && !bfsVisit[i]) {
                bfsVisit[i] = true;
                printf("Visited %d\n", i);
                bfsEnqueue(queue, i);
            }
        }
    }

    free(queue);
}
// prim
#define primTRUE 1 /* 지나간 경로 표시 */
#define primFALSE -1
#define primVERTICES 5001 /* 최대 정점의 수 */
#define primINF 1000L 
int prim_adj_mat[primVERTICES][primVERTICES]; /* 정점의 위치 저장 배열 */
int prim_dist[primVERTICES]; /* 간선의 최소값을 저장하기 위한 배열 */
/* Prim Algorithm */
int prim(int s, int n) /* S - 정점 배열의 시작점 위치, N - 배열의 크기 */
{
    /* Integer */
    int min = primINF; /* 가중치 최솟값을 저장하는 변수 */
    int idx = 0; /* 가중치 값을 저장하는 변수 */
    int sum = 0; /* 가중치 최솟값을 더하는 변수 */
    int count, ii;

    /* 간선의 최소값을 저장하는 배열 초기화 */
    for (count = 1; count <= n; count++) { prim_dist[count] = prim_adj_mat[1][count]; }

    /* 가중치 배열 첫 부분 표시 */
    prim_dist[s] = FALSE;
    for (count = 1; count < n; count++)
    {
        /* 검색을 시작할 노드 선택 */
        min = primINF;
        /* 최소 가중치 값을 반환하는 반복문 */
        for (ii = 1; ii <= n; ii++)
        {
            /* 정점간 연결이 되어있거나 가중치 최솟값 보다 정점간 가중치 값이 작은경우 */
            if ((prim_dist[ii] != FALSE) && (min > prim_dist[ii]))
            {
                /* 정점간의 가중치를 가중치 최솟값에 저장 */
                min = prim_dist[ii];
                /* 현재 정점들간의 연결 된 위치를 저장 */
                idx = ii;
            }
        }

        /* 최솟값을 더하여 저장 */
        sum += min;
        /* 다음 검색을 할 노드 선택 */
        prim_dist[idx] = FALSE;

        /* 현재 저장 된 최소 가중치와 비교 된 가중치 값이 더 작은 경우 최소 가중치 값을 변경한다. */
        for (ii = 1; ii <= n; ii++) { if (prim_dist[ii] > prim_adj_mat[idx][ii]) { prim_dist[ii] = prim_adj_mat[idx][ii]; } }
    }

    /* 최소 가중치 합 변수 반환 */
    return sum;
}

// kruskal
#define MAX_VER 100
int parent[MAX_VER];
int num[MAX_VER];
void init_set(int n) {
    int i;
    for (i = 0; i < n; i++) {
        //- : 정점, 음수의 숫자 : 집합의 갯수, 양수의 수 : 원소의 부모
        parent[i] = -1;
        // 각 정점들의 집합의 갯수
        num[i] = 1;
    }
}
int find_set(int vertex) {
    int whatp, p, i = -1;
    for (i = vertex; (whatp = parent[i]) >= 0; i = whatp)
        ;    // 원소의 parent를 찾아감
    p = i; //parent를 발견해냄.
    for (i = vertex; (whatp = parent[i]) >= 0; i = whatp)
        parent[i] = p;  // 원소의 parent
    return p;
}
void union_set(int r1, int r2) {
    if (num[r1] < num[r2]) {
        parent[r1] = r2;   //r2 = 부모노드가 될것  r1  = 자식
        num[r2] += num[r1]; // r2의 갯수가 r1의 집합의 갯수만큼 들어남.
    }
    else {
        parent[r2] = r1;
        num[r1] += num[r2];
    }
}
typedef struct {
    int src;
    int dest;
    int weight;
}forSort;
int compare(const void* a, const void* b) {
    const forSort* m1 = (const forSort*)a;
    const forSort* m2 = (const forSort*)b;
    return m1->weight - m2->weight;
}
void kruskal(int cost[9][9]) {
    int i, j;
    int index = 0;
    int edge_count = 0;
    int min, mincost = 0;
    int uset, vset; //정점 u와 정점 v의 집합 번호
    forSort arr[MAX_VER] = { 0 };
    for (i = 0; i < 9; i++) {
        for (j = 0; j < 9; j++) {
            if (cost[i][j] != 0) {
                arr[index].weight = cost[i][j];
                cost[j][i] = 0;
                arr[index].src = i;     // 해당 가중치의 정점 2개를 기억하기위한 배열
                arr[index].dest = j;
                index++;
            }
        }
    }
    qsort(arr, index, sizeof(forSort), compare);  //-->tmp_arr배열에 저장된 가중치가 오름차순으로 정리
    for (i = 0; i < index; i++) {     // --> qsort확인
        printf("%d\n", arr[i].weight);
    }
    init_set(9);
    i = 0;
    while (edge_count < (9 - 1)) {
        if (i < index) {
            min = arr[i].weight;
            uset = find_set(arr[i].src);
            vset = find_set(arr[i].dest);
            if (uset != vset) {
                edge_count++;
                union_set(uset, vset);
                mincost += min;
                printf("선택한 가중치: %d\t-->", min);
                printf("현재 최소값 : %d\n", mincost);
            }
            i++;
        }
    }
    printf("\n최소값 : %d \n", mincost);
}

// Topological sort
#define TSSIZE 100
/* 해당 인덱스에 연결된 노드 */
typedef struct a link;
struct a {
    int num;  // 연결된 노드 이름(인덱스 번호)
    link* next;  // 다음 연결된 노드 주소
};
/* 해당 인덱스의 진입차수, 연결된 노드 */
typedef struct {
    int degree;  // 진입차수
    link* linked;  // 연결된 노드 정보
}data;
int topology_sort(data* arr[TSSIZE], int* result, int count)
{
    /* 정렬 수행을 위한 큐 */
    int queue[TSSIZE];
    int n = 0;  // queue count
    int r = 0;  // result count

    /* 위상 정렬 수행 */
    while (1)
    {
        /* 진입차수가 0인 항목을 큐와 result에 동시에 담아줌 */
        for (int i = 0; i < TSSIZE; i++)
            if (arr[i] != NULL && arr[i]->degree == 0)
            {
                queue[n++] = i;
                result[r++] = i;
                arr[i]->degree--;
            }

        /* 종료 조건 */
        if (n == 0)
        {
            if (r == count)  // 전체 노드 갯수가 맞다면 정상 종료
                return 0;
            else return 1;
        }

        /* 큐에 담긴 노드에 연결된 노드의 degree 감소 */
        for (int i = 0; i < n; i++)
        {
            link* p = arr[queue[i]]->linked;
            while (p != NULL)
            {
                arr[p->num]->degree--;
                p = p->next;
            }
        }
        n = 0;	// queue count 초기화
    }
}
void linking(data* arr[TSSIZE], int index, int x)
{
    link* temp = NULL;
    if ((temp = (link*)malloc(sizeof(link))) == NULL)
        exit(3);
    temp->num = x;  // 연결된 노드 
    temp->next = NULL;  // 다음 연결 노드 (기본값 NULL)

    if (arr[index]->linked == NULL)  // 현재 연결 노드가 하나도 없을 때
        arr[index]->linked = temp;
    else  // 현재 연결 노드가 있을 때
    {
        link* p = arr[index]->linked;
        while (p->next != NULL)
            p = p->next;
        p->next = temp;  // 마지막 연결 노드에 붙여줌
    }
}
void create_data(data* arr[TSSIZE], int index, int x)
{
    data* temp = NULL;
    if (arr[index] == NULL)  // 비어있을 경우 새로 생성
    {
        if ((temp = (data*)malloc(sizeof(data))) == NULL)
            exit(1);
        temp->degree = 0;
        temp->linked = NULL;
        arr[index] = temp;
    }
    if (arr[x] == NULL)  // 비어있을 경우 새로 생성
    {
        if ((temp = (data*)malloc(sizeof(data))) == NULL)
            exit(2);
        temp->degree = 0;
        temp->linked = NULL;
        arr[x] = temp;
    }
    arr[x]->degree++;  // 진입차수 1 증가

    linking(arr, index, x);  // 연결된 노드 생성
}
void print_all(data* arr[TSSIZE], int* result, int count)
{
    printf("\n");
    for (int i = 0; i < TSSIZE; i++)
        if (arr[i] != NULL)
        {
            printf("  num : %d ", i);
            link* p = arr[i]->linked;
            if (p != NULL) printf("->");
            while (p != NULL)
            {
                printf(" %d ", p->num);
                p = p->next;
            }
            printf(" (degree : %d)\n", arr[i]->degree);
        }
    printf("\n  최종결과 : ");
    for (int i = 0; i < count; i++)
        printf("%d ", result[i]);
    printf("\n");
}


int main() {

    int choice1, choice2;
    int* arr = NULL;

    do {
        printf("\t\t\t  ___   _      _____  _____ ______  _____  _____  _   _ ___  ___\n");
        printf("\t\t\t / _ \\ | |    |  __ \\|  _  || ___ \\|_   _||_   _|| | | ||  \\/  |\n");
        printf("\t\t\t/ /_\\ \\| |    | |  \\/| | | || |_/ /  | |    | |  | |_| || .  . |\n");
        printf("\t\t\t|  _  || |    | | __ | | | ||    /   | |    | |  |  _  || |\\/| |\n");
        printf("\t\t\t| | | || |____| |_\\ \\\\ \\_/ /| |\\ \\  _| |_   | |  | | | || |  | |\n");
        printf("\t\t\t\\_| |_/\\_____/\\____/  \\___/ \\_| \\_| \\___/   \\_/  \\_| |_|\\_|  |_/\n");
        printf("\n");
        printf("\n");
        printf("\n");

        gotoxy(30, 10);
        printf("1. 정렬 알고리즘\n");
        gotoxy(32, 11);
        printf("2. 그래프\n");
        gotoxy(34, 12);
        printf("3. 종료\n");
        gotoxy(34, 13);
        printf("원하는 선택지를 고르시오: ");
        scanf_s("%d", &choice1);
        system("cls");
        switch (choice1) {
        case 1:
            printf("정렬 알고리즘 목록입니다.\n");
            do {
                system("cls");
                // 첫 번째 줄
                gotoxy(15, 3);
                printf("  _______   ______   .______     ______   .__   __.   _______ .______        ___      .______   \n");

                // 두 번째 줄
                gotoxy(15, 4);
                printf(" /  _____| /  __  \\  |   _  \\   /  __  \\  |  \\ |  |  /  _____||   _  \\      /   \\     |   _  \\  \n");

                // 세 번째 줄
                gotoxy(15, 5);
                printf("|  |  __  |  |  |  | |  |_)  | |  |  |  | |   \\|  | |  |  __  |  |_)  |    /  ^  \\    |  |_)  | \n");

                // 네 번째 줄
                gotoxy(15, 6);
                printf("|  | |_ | |  |  |  | |   _  <  |  |  |  | |  . `  | |  | |_ | |   _  <    /  /_\\  \\   |   _  <  \n");

                // 다섯 번째 줄
                gotoxy(15, 7);
                printf("|  |__| | |  `--'  | |  |_)  | |  `--'  | |  |\\   | |  |__| | |  |_)  |  /  _____  \\  |  |_)  | \n");

                // 여섯 번째 줄
                gotoxy(15, 8);
                printf(" \\______|  \\______/  |______/   \\______/  |__| \\__|  \\______| |______/  /__/     \\__\\ |______/  \n");


                gotoxy(27, 10);
                printf("1. 버블 정렬\n");
                gotoxy(28, 11);
                printf("2. 선택 정렬\n");
                gotoxy(29, 12);
                printf("3. 삽입 정렬\n");
                gotoxy(30, 13);
                printf("4. 퀵 정렬\n");
                gotoxy(31, 14);
                printf("5. 병합 정렬\n");
                gotoxy(32, 15);
                printf("6. 힙 정렬\n");
                gotoxy(33, 16);
                printf("7. 기수 정렬\n");
                gotoxy(34, 17);
                printf("8. 뒤로 가기\n");
                gotoxy(35, 18);

                printf("☆원하는 옵션을 선택하세요:");
                scanf_s("%d", &choice2);

                switch (choice2) {
                case 1:
                    system("cls");
                    gotoxy(15, 5);
                    printf("______         _      _      _       \n");
                    gotoxy(15, 6);
                    printf("| ___ \\       | |    | |    | |      \n");
                    gotoxy(15, 7);
                    printf("| |_/ / _   _ | |__  | |__  | |  ___ \n");
                    gotoxy(15, 8);
                    printf("| ___ \\| | | || '_ \\ | '_ \\ | | / _ \\\n");
                    gotoxy(15, 9);
                    printf("| |_/ /| |_| || |_) || |_) || ||  __/\n");
                    gotoxy(15, 10);
                    printf("\\____/  \\__,_||_.__/ |_.__/ |_| \\___|\n");

                    gotoxy(15, 13);
                    printf("버블 정렬을 선택했습니다.\n");
                    int n; // 배열의 크기
                    gotoxy(15, 13);
                    printf("배열의 크기를 입력하세요: ");
                    scanf_s("%d", &n);
                    if (n <= 0) {
                        printf("유효하지 않은 크기입니다. 양수를 입력하세요.\n");
                        break; // 올바른 크기를 입력받을 때까지 계속 반복
                    }
                    arr = (int*)malloc(n * sizeof(int));
                    if (arr == NULL) {
                        printf("메모리 할당 실패\n");
                        break;
                    }
                    system("cls");
                    printf("하나씩 배열의 요소를 입력하세요:\n");
                    for (int i = 0; i < n; i++) {
                        printf("arr[%d]: ", i);
                        scanf_s("%d", &arr[i]);
                    }

                    system("cls");

                    printf("사용자가 입력한 배열은: \n\t\t");
                    for (int i = 0; i < n; i++) {
                        printf("%1d ", arr[i]);
                    }
                    printf("\n");
                    bubble_sort(arr, n);

                    gotoxy(40, 2);
                    printf("버블 정렬(bubble sort) 알고리즘의 개념 요약\n");

                    gotoxy(40, 3);
                    printf("서로 인접한 두 원소를 검사하여 정렬하는 알고리즘\n");

                    gotoxy(40, 4);
                    printf("인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환한다.\n");

                    gotoxy(40, 5);
                    printf("선택 정렬과 기본 개념이 유사하다.\n");

                    // 버블 정렬 알고리즘 구체적인 개념
                    gotoxy(40, 7);
                    printf("버블 정렬(bubble sort) 알고리즘의 구체적인 개념\n");

                    gotoxy(40, 8);
                    printf("버블 정렬은 첫 번째 자료와 두 번째 자료를 비교하여 교환하면서,\n");

                    gotoxy(40, 9);
                    printf("두 번째 자료와 세 번째 자료를 비교하여 교환하면서,\n");

                    gotoxy(40, 10);
                    printf("세 번째와 네 번째를 비교하여 교환하는 식으로 진행된다.\n");

                    gotoxy(40, 11);
                    printf("(마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.\n");

                    gotoxy(40, 12);
                    printf("1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로,\n");

                    gotoxy(40, 13);
                    printf("2회전에서는 맨 끝에 있는 자료는 정렬에서 제외되고,\n");

                    gotoxy(40, 14);
                    printf("2회전을 수행하고 나면 끝에서 두 번째 자료까지는 정렬에서 제외된다.\n");

                    gotoxy(40, 15);
                    printf("이렇게 정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다.\n");


                    free(arr); // 정렬 후 메모리를 해제
                    arr = NULL;

                    // 옵션 A를 수행하는 코드 추가
                    int goBack1; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(4, 20);
                        printf("1. 코드 자세히 보기\n");
                        gotoxy(4, 21);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(4, 22);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack1);

                        switch (goBack1) {
                        case 1:
                            system("cls");
                            gotoxy(5, 5);
                            printf("void bubble_sort(int* arr, int n) {");
                            gotoxy(5, 6);
                            printf("    for (int i = 0; i < n - 1; i++) {");
                            gotoxy(5, 7);
                            printf("        for (int j = 0; j < n - i - 1; j++) {");
                            gotoxy(5, 8);
                            printf("            if (arr[j] > arr[j + 1]) {");
                            gotoxy(5, 9);
                            printf("                swap(&arr[j], &arr[j + 1]);");
                            gotoxy(5, 10);
                            printf("           }");
                            gotoxy(5, 11);
                            printf("        }");
                            gotoxy(5, 12);
                            printf("    }");
                            gotoxy(5, 13);
                            printf("}");
                            printf("\n");
                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack1 != 2); // 목록으로 돌아가기 루프

                    // 옵션 A를 수행하는 코드 추가
                    break;
                case 2:
                    system("cls");
                    gotoxy(15, 5);
                    printf(" _____        _              _    _               \n");
                    gotoxy(15, 6);
                    printf("/  ___|      | |            | |  (_)              \n");
                    gotoxy(15, 7);
                    printf("\\ `--.   ___ | |  ___   ___ | |_  _   ___   _ __  \n");
                    gotoxy(15, 8);
                    printf(" `--. \\ / _ \\| | / _ \\ / __|| __|| | / _ \\ | '_ \\ \n");
                    gotoxy(15, 9);
                    printf("/\\__/ /|  __/| ||  __/| (__ | |_ | || (_) || | | |\n");
                    gotoxy(15, 10);
                    printf("\\____/  \\___||_| \\___| \\___| \\__||_| \\___/ |_| |_|\n");
                    gotoxy(15, 12);
                    int m;
                    printf("배열의 크기를 입력하세요: ");
                    scanf_s("%d", &m);

                    if (m <= 0) {
                        printf("유효하지 않은 크기입니다. 양수를 입력하세요.\n");
                        break;
                    }

                    arr = (int*)malloc(m * sizeof(int));
                    if (arr == NULL) {
                        printf("메모리 할당 실패\n");
                        break;
                    }
                    system("cls");
                    printf("하나씩 배열의 요소를 입력하세요:\n");
                    for (int i = 0; i < m; i++) {
                        printf("arr[%d]: ", i);
                        scanf_s("%d", &arr[i]);
                    }
                    system("cls");
                    printf("사용자가 입력한 배열은: \n\t\t");
                    for (int i = 0; i < m; i++) {
                        printf("%1d ", arr[i]);
                    }

                    printf("\n");
                    selection_sort(arr, m);

                    // 선택 정렬(selection sort) 알고리즘 개념 요약
                    gotoxy(40, 2);
                    printf("선택 정렬(selection sort) 알고리즘 개념 요약");
                    gotoxy(40, 3);
                    printf("제자리 정렬(in-place sorting) 알고리즘의 하나");
                    gotoxy(40, 4);
                    printf("입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법");
                    gotoxy(40, 5);
                    printf("해당 순서에 원소를 넣을 위치는 이미 정해져 있고,");
                    gotoxy(40, 6);
                    printf("어떤 원소를 넣을지 선택하는 알고리즘");
                    gotoxy(40, 7);
                    printf("첫 번째 순서에는 첫 번째 위치에 가장 최솟값을 넣는다.");
                    gotoxy(40, 8);
                    printf("두 번째 순서에는 두 번째 위치에 남은 값 중에서의 최솟값을 넣는다.");
                    gotoxy(40, 9);
                    printf("...");
                    gotoxy(40, 11);
                    printf("과정 설명");
                    gotoxy(40, 12);
                    printf("주어진 배열 중에서 최솟값을 찾는다.");
                    gotoxy(40, 13);
                    printf("그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).");
                    gotoxy(40, 14);
                    printf("맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.");
                    gotoxy(40, 15);
                    printf("하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다.");
                    // 선택 정렬(selection sort) 알고리즘의 구체적인 개념
                    gotoxy(40, 17);
                    printf("선택 정렬(selection sort) 알고리즘의 구체적인 개념");
                    gotoxy(40, 18);
                    printf("선택 정렬은 첫 번째 자료를 두 번째 자료부터 마지막 자료까지 차례대로 비교하여");
                    gotoxy(40, 19);
                    printf("가장 작은 값을 찾아 첫 번째에 놓고,");
                    gotoxy(40, 20);
                    printf("두 번째 자료를 세 번째 자료부터 마지막 자료까지와 차례대로 비교하여");
                    gotoxy(40, 21);
                    printf("그 중 가장 작은 값을 찾아 두 번째 위치에 놓는 과정을 반복하며 정렬을 수행한다.");
                    gotoxy(40, 22);
                    printf("1회전을 수행하고 나면 가장 작은 값의 자료가 맨 앞에 오게 되므로");
                    gotoxy(40, 23);
                    printf("그 다음 회전에서는 두 번째 자료를 가지고 비교한다.");
                    gotoxy(40, 24);
                    printf("마찬가지로 3회전에서는 세 번째 자료를 정렬한다.");

                    free(arr); // 정렬 후 메모리를 해제
                    arr = NULL;

                    int goBack2; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(4, 20);
                        printf("1. 코드 자세히 보기\n");
                        gotoxy(4, 21);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(4, 22);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack2);

                        switch (goBack2) {
                        case 1:
                            system("cls");
                            gotoxy(5, 5);
                            printf("void selectionSort(int arr[], int n) {\n");
                            gotoxy(5, 6);
                            printf("    int i, j, min;\n");
                            gotoxy(5, 7);
                            printf("    for (i = 0; i < n - 1; i++) {\n");
                            gotoxy(5, 8);
                            printf("        min = i;\n");
                            gotoxy(5, 9);
                            printf("        for (j = i + 1; j < n; j++) {\n");
                            gotoxy(5, 10);
                            printf("            if (arr[j] < arr[min]) {\n");
                            gotoxy(5, 11);
                            printf("                min = j;\n");
                            gotoxy(5, 12);
                            printf("            }\n");
                            gotoxy(5, 13);
                            printf("        }\n");
                            gotoxy(5, 14);
                            printf("        int temp = arr[min];\n");
                            gotoxy(5, 15);
                            printf("        arr[min] = arr[i];\n");
                            gotoxy(5, 16);
                            printf("        arr[i] = temp;\n");
                            gotoxy(5, 17);
                            printf("    }\n");
                            gotoxy(5, 18);
                            printf("}\n");

                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack2 != 2); // 목록으로 돌아가기 루프
                    break;
                case 3:
                    system("cls");
                    gotoxy(15, 2);
                    printf(" __  .__   __.      _______. _______ .______      .___________. __    ______   .__   __.");
                    gotoxy(15, 3);
                    printf("|  | |  \\ |  |     /       ||   ____||   _  \\     |           ||  |  /  __  \\  |  \\ |  |");
                    gotoxy(15, 4);
                    printf("|  | |   \\|  |    |   (----`|  |__   |  |_)  |    `---|  |----`|  | |  |  |  | |   \\|  |");
                    gotoxy(15, 5);
                    printf("|  | |  . `  |     \\   \\    |   __|  |      /         |  |     |  | |  |  |  | |  . `  |");
                    gotoxy(15, 6);
                    printf("|  | |  |\\   | .----)   |   |  |____ |  |\\  \\----.    |  |     |  | |  `--'  | |  |\\   |");
                    gotoxy(15, 7);
                    printf("|__| |__| \\__| |_______/    |_______|| _| `._____|    |__|     |__|  \\______/  |__| \\__|");

                    int p;
                    gotoxy(15, 9);
                    printf("배열의 크기를 입력하세요: ");
                    scanf_s("%d", &p);

                    if (p <= 0) {
                        printf("유효하지 않은 크기입니다. 양수를 입력하세요.\n");
                        break;
                    }

                    arr = (int*)malloc(p * sizeof(int));
                    if (arr == NULL) {
                        printf("메모리 할당 실패\n");
                        break;
                    }
                    system("cls");
                    printf("배열의 요소를 입력하세요:\n");
                    for (int i = 0; i < p; i++) {
                        printf("arr[%d]: ", i);
                        scanf_s("%d", &arr[i]);
                    }
                    system("cls");
                    printf("사용자가 입력한 배열은: \n\t\t");
                    for (int i = 0; i < p; i++) {
                        printf("%1d ", arr[i]);
                    }

                    printf("\n");
                    insertion_sort(arr, p);

                    // 선택 정렬(selection sort) 알고리즘 개념 요약
                    gotoxy(40, 2);
                    printf("삽입 정렬(insertion sort) 알고리즘 개념 요약");
                    gotoxy(40, 3);
                    printf("손안의 카드를 정렬하는 방법과 유사하다.");
                    gotoxy(40, 4);
                    printf("새로운 카드를 기존의 정렬된 카드 사이의 올바른 자리를 찾아 삽입한다.");
                    gotoxy(40, 5);
                    printf("새로 삽입될 카드의 수만큼 반복하게 되면 전체 카드가 정렬된다.");
                    gotoxy(40, 6);
                    printf("자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여,");
                    gotoxy(40, 7);
                    printf("자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘");
                    gotoxy(40, 8);
                    printf("매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다.");
                    gotoxy(40, 9);
                    printf("...");
                    gotoxy(40, 11);
                    printf("삽입 정렬(insertion sort) 알고리즘의 구체적인 개념");
                    gotoxy(40, 12);
                    printf("삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 ");
                    gotoxy(40, 13);
                    printf("삽입할 위치를 지정한 후 자료를 뒤로 옮기고 ");
                    gotoxy(40, 14);
                    printf("지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.");
                    gotoxy(40, 15);
                    printf("즉, 두 번째 자료는 첫 번째 자료, ");
                    gotoxy(40, 16);
                    printf("세 번째 자료는 두 번째와 첫 번째 자료,");
                    gotoxy(40, 17);
                    printf("네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 ");
                    gotoxy(40, 18);
                    printf("비교한 후 자료가 삽입될 위치를 찾는다. ");
                    gotoxy(40, 19);
                    printf("자료가 삽입될 위치를 찾았다면 그 위치에");
                    gotoxy(40, 20);
                    printf("자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.");
                    gotoxy(40, 21);
                    printf("처음 Key 값은 두 번째 자료부터 시작한다.");

                    free(arr); // 정렬 후 메모리를 해제
                    arr = NULL;

                    int goBack3; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(4, 20);
                        printf("1. 코드 자세히 보기\n");
                        gotoxy(4, 21);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(4, 22);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack3);

                        switch (goBack3) {
                        case 1:
                            system("cls");
                            gotoxy(2, 2);
                            printf("void insertion_sort(int arr[], int n) {");
                            gotoxy(5, 6);
                            printf("	int key, j = 0;");
                            gotoxy(5, 7);
                            printf("	for (int i = 0; i < n; i++) {");
                            gotoxy(5, 8);
                            printf("		key = arr[i];");
                            gotoxy(5, 9);
                            printf("		j = i - 1;");
                            gotoxy(5, 10);
                            printf("		while (j >= 0 && arr[j] > key) {");
                            gotoxy(5, 11);
                            printf("			arr[j + 1] = arr[j];");
                            gotoxy(5, 12);
                            printf("			j--;");
                            gotoxy(5, 13);
                            printf("		}");
                            gotoxy(5, 14);
                            printf("		arr[j + 1] = key;");
                            gotoxy(5, 15);
                            printf("	}");
                            gotoxy(5, 16);
                            printf("}");
                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack3 != 2); // 목록으로 돌아가기 루프
                    break;
                case 4:
                    system("cls");
                    gotoxy(15, 2);
                    printf("  ______       __    __   __    ______  __  ___ ");

                    gotoxy(15, 3);
                    printf(" /  __  \\     |  |  |  | |  |  /      ||  |/  / ");

                    gotoxy(15, 4);
                    printf("|  |  |  |    |  |  |  | |  | |  ,----'|  '  /  ");

                    gotoxy(15, 5);
                    printf("|  |  |  |    |  |  |  | |  | |  |     |    <   ");

                    gotoxy(15, 6);
                    printf("|  `--'  '--. |  `--'  | |  | |  `----.|  .  \\  ");

                    gotoxy(15, 7);
                    printf(" \\_____/\\_____\\\\______/  |__|  \\______||__|\\__\\ ");

                    gotoxy(15, 10);
                    printf("*주의사항* 퀵 정렬은 분할 정복입니다. 더이상 분할할 수 없다면 문구가 나옵니다.");
                    int q;
                    gotoxy(15, 9);
                    printf("배열의 크기를 입력하세요: ");
                    scanf_s("%d", &q);

                    if (q <= 0) {
                        printf("유효하지 않은 크기입니다. 양수를 입력하세요.\n");
                        break;
                    }

                    arr = (int*)malloc(q * sizeof(int));
                    if (arr == NULL) {
                        printf("메모리 할당 실패\n");
                        break;
                    }

                    system("cls");
                    printf("배열의 요소를 입력하세요:\n");
                    for (int i = 0; i < q; i++) {
                        printf("arr[%d]: ", i);
                        scanf_s("%d", &arr[i]);
                    }
                    system("cls");
                    printf("사용자가 입력한 배열은: \n\t\t");
                    for (int i = 0; i < q; i++) {
                        printf("%1d ", arr[i]);
                    }

                    quick_sort(arr, 0, q - 1);

                    printf("정렬된 이후 배열의 모습은: \n");
                    for (int i = 0; i < q; i++) {
                        printf("%1d ", arr[i]);
                    }

                    free(arr); // 정렬 후 메모리를 해제
                    arr = NULL;

                    int goBack4; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(40, 25);
                        printf("1. 코드 및 설명 자세히 보기\n");
                        gotoxy(40, 26);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(40, 27);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack4);

                        switch (goBack4) {
                        case 1:
                            system("cls");
                            gotoxy(2, 3);
                            printf("void quick_sort(int arr[], int left, int right) {");

                            gotoxy(2, 4);
                            printf("    if (left < right) {");

                            gotoxy(2, 5);
                            printf("        int pivot = partition(arr, left, right);");

                            gotoxy(2, 6);
                            printf("        quick_sort(arr, left, pivot - 1);");

                            gotoxy(2, 7);
                            printf("        quick_sort(arr, pivot + 1, right);");

                            gotoxy(2, 8);
                            printf("    }");

                            gotoxy(2, 9);
                            printf("}");

                            gotoxy(2, 10);
                            printf("int partition(int arr[], int left, int right) {");

                            gotoxy(2, 11);
                            printf("    int pivot = arr[right];");

                            gotoxy(2, 12);
                            printf("    int i = left - 1;");

                            gotoxy(2, 13);
                            printf("    for (int j = left; j < right; j++) {");

                            gotoxy(2, 14);
                            printf("        if (arr[j] < pivot) {");

                            gotoxy(2, 15);
                            printf("            i++;");

                            gotoxy(2, 16);
                            printf("            swap(&arr[i], &arr[j]);");

                            gotoxy(2, 17);
                            printf("        }");

                            gotoxy(2, 18);
                            printf("    }");

                            gotoxy(2, 19);
                            printf("    swap(&arr[i + 1], &arr[right]);");

                            gotoxy(2, 20);
                            printf("    return i + 1;");

                            gotoxy(2, 21);
                            printf("}");

                            // 퀵 정렬(quick sort) 알고리즘의 개념 요약
                            gotoxy(55, 3);
                            printf("퀵 정렬(quick sort) 알고리즘의 개념 요약");

                            gotoxy(55, 4);
                            printf("‘찰스 앤터니 리처드 호어’가 개발한 정렬 알고리즘");

                            gotoxy(55, 5);
                            printf("퀵 정렬은 불안정 정렬에 속하며,");

                            gotoxy(55, 6);
                            printf("다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다.");

                            gotoxy(55, 7);
                            printf("분할 정복 알고리즘의 하나로,");

                            gotoxy(55, 8);
                            printf("평균적으로 매우 빠른 수행 속도를 자랑하는 정렬 방법");

                            gotoxy(55, 9);
                            printf("합병 정렬과 달리 퀵 정렬은 리스트를 비균등하게 분할한다.");

                            gotoxy(55, 10);
                            printf("분할 정복(divide and conquer) 방법");

                            gotoxy(55, 11);
                            printf("문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음,");

                            gotoxy(55, 12);
                            printf("결과를 모아서 원래의 문제를 해결하는 전략이다.");

                            gotoxy(55, 13);
                            printf("분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.");

                            // 과정 설명
                            gotoxy(55, 14);
                            printf("과정 설명");

                            gotoxy(55, 15);
                            printf("1. 리스트 안에 있는 한 요소를 선택한다.고른 원소를 피벗이라 한다.");

                            gotoxy(55, 16);
                            printf("2. 피벗을 기준으로 피벗보다 작은 요소들은 피벗의 왼쪽으로 이동");
                            gotoxy(55, 17);
                            printf("피벗보다 큰 요소들은 피벗의 오른쪽으로 이동.");
                            gotoxy(55, 18);
                            printf("3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.");

                            gotoxy(55, 19);
                            printf("- 분할된 부분 리스트에 대하여 순환 호출을 이용하여 정렬을 반복함.");

                            gotoxy(55, 20);
                            printf("- 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 ");
                            gotoxy(55, 21);
                            printf("2개의 부분 리스트로 나누는 과정을 반복한다.");

                            gotoxy(55, 22);
                            printf("4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.");

                            gotoxy(55, 23);
                            printf("- 리스트의 크기가 0이나 1이 될 때까지 반복한다.");

                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack4 != 2); // 목록으로 돌아가기 루프
                    break;

                case 5:
                    system("cls");
                    gotoxy(15, 2);
                    printf("          ___  ___                         \n");
                    gotoxy(15, 3);
                    printf("         |  \\/  |                         \n");
                    gotoxy(15, 4);
                    printf("         | .  . |  ___  _ __   __ _   ___ \n");
                    gotoxy(15, 5);
                    printf("         | |\\/| | / _ \\| '__| / _` | / _ \\\n");
                    gotoxy(15, 6);
                    printf("         | |  | ||  __/| |   | (_| ||  __/\n");
                    gotoxy(15, 7);
                    printf("         \\_|  |_/ \\___||_|    \\__, | \\___|\n");
                    gotoxy(15, 8);
                    printf("                               __/ |      \n");
                    gotoxy(15, 9);
                    printf("                              |___/       \n");

                    int o;
                    gotoxy(15, 11);
                    printf("배열의 크기를 입력하세요: (제한범위 20)\n");
                    scanf_s("%d", &o);

                    if (o <= 0) {
                        printf("유효하지 않은 크기입니다. 양수를 입력하세요.\n");
                        break;
                    }

                    int* arr = (int*)malloc(o * sizeof(int));
                    if (arr == NULL) {
                        printf("메모리 할당 실패\n");
                        break;
                    }

                    system("cls");

                    printf("배열의 요소를 입력하세요:\n");
                    for (int i = 0; i < o; i++) {
                        printf("arr[%d]: ", i);
                        scanf_s("%d", &arr[i]);
                    }

                    system("cls");

                    printf("사용자가 입력한 배열은: \n\t\t");
                    for (int i = 0; i < o; i++) {
                        printf("%d ", arr[i]);
                    }

                    printf("\n");
                    printf("정렬 전: ");
                    print_merge(arr, o);
                    printf("\n");

                    merge_sort(arr, 0, o - 1);

                    printf("정렬 후: ");
                    print_merge(arr, o);

                    printf("\n");

                    free(arr); // 동적 메모리 해제

                    int goBack5; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(50, 25);
                        printf("1. 코드 및 설명 자세히 보기\n");
                        gotoxy(50, 26);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(50, 27);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack5);

                        switch (goBack5) {
                        case 1:
                            system("cls");
                            gotoxy(4, 1);
                            printf("int sorted[20];\n");

                            gotoxy(4, 3);
                            printf("void merge(int arr[], int l, int m, int r) {\n");

                            gotoxy(4, 4);
                            printf("    int i = l;\n");

                            gotoxy(4, 5);
                            printf("    int j = m + 1;\n");

                            gotoxy(4, 6);
                            printf("    int k = l;\n");

                            gotoxy(4, 7);
                            printf("    \n");

                            gotoxy(4, 8);
                            printf("    while (i <= m && j <= r) {\n");

                            gotoxy(4, 9);
                            printf("        if (arr[i] <= arr[j]) {\n");

                            gotoxy(4, 10);
                            printf("            sorted[k++] = arr[i++];\n");

                            gotoxy(4, 11);
                            printf("        } else {\n");

                            gotoxy(4, 12);
                            printf("            sorted[k++] = arr[j++];\n");

                            gotoxy(4, 13);
                            printf("        }\n");

                            gotoxy(4, 14);
                            printf("    }\n");

                            gotoxy(4, 15);
                            printf("    if (i > m) {\n");

                            gotoxy(4, 16);
                            printf("        for (; j <= r; j++) {\n");

                            gotoxy(4, 17);
                            printf("            sorted[k++] = arr[j];\n");

                            gotoxy(4, 18);
                            printf("        }\n");

                            gotoxy(4, 19);
                            printf("    } else {\n");

                            gotoxy(4, 20);
                            printf("        for (; i <= m; i++) {\n");

                            gotoxy(4, 21);
                            printf("            sorted[k++] = arr[i];\n");

                            gotoxy(4, 22);
                            printf("        }\n");

                            gotoxy(4, 23);
                            printf("    }\n");

                            gotoxy(4, 24);
                            printf("    for (int i = l; i <= r; i++) {\n");

                            gotoxy(4, 25);
                            printf("        arr[i] = sorted[i];\n");

                            gotoxy(4, 26);
                            printf("    }\n");

                            gotoxy(4, 27);
                            printf("}\n");

                            gotoxy(4, 29);
                            printf("void merge_sort(int arr[], int l, int r) {\n");

                            gotoxy(4, 30);
                            printf("    if (l < r) {\n");

                            gotoxy(4, 31);
                            printf("        int m = (l + r) / 2;\n");

                            gotoxy(4, 32);
                            printf("        \n");

                            gotoxy(4, 33);
                            printf("        merge_sort(arr, l, m);\n");

                            gotoxy(4, 34);
                            printf("        merge_sort(arr, m + 1, r);\n");

                            gotoxy(4, 35);
                            printf("        \n");

                            gotoxy(4, 36);
                            printf("        merge(arr, l, m, r);\n");

                            gotoxy(4, 37);
                            printf("    }\n");

                            gotoxy(4, 38);
                            printf("}\n");

                            gotoxy(55, 3);
                            printf("합병 정렬(merge sort) 알고리즘의 개념 요약");

                            gotoxy(55, 4);
                            printf("‘존 폰 노이만(John von Neumann)’이라는 사람이 제안한 방법");

                            gotoxy(55, 5);
                            printf("일반적인 방법으로 구현했을 때 이 정렬은 안정 정렬에 속하며,");

                            gotoxy(55, 6);
                            printf("분할 정복 알고리즘의 하나이다.");

                            gotoxy(55, 7);
                            printf("분할 정복(divide and conquer) 방법");

                            gotoxy(55, 8);
                            printf("문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음,");

                            gotoxy(55, 9);
                            printf("결과를 모아서 원래의 문제를 해결하는 전략이다.");

                            gotoxy(55, 10);
                            printf("분할 정복 방법은 대개 순환 호출을 이용하여 구현한다.");

                            gotoxy(55, 11);
                            printf("과정 설명");

                            gotoxy(55, 12);
                            printf("리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다.");

                            gotoxy(55, 13);
                            printf("그렇지 않은 경우에는 정렬되지 않은 리스트를 절반으로 잘라");

                            gotoxy(55, 14);
                            printf("비슷한 크기의 두 부분 리스트로 나눈다.");

                            gotoxy(55, 15);
                            printf("각 부분 리스트를 재귀적으로 합병 정렬을 이용해 정렬한다.");

                            gotoxy(55, 16);
                            printf("두 부분 리스트를 다시 하나의 정렬된 리스트로 합병한다.");

                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack5 != 2); // 목록으로 돌아가기 루프
                    break;
                case 6:
                    system("cls");
                    gotoxy(20, 1);
                    printf(" _   _                     \n");

                    gotoxy(20, 2);
                    printf("| | | |                    \n");

                    gotoxy(20, 3);
                    printf("| |_| |  ___   __ _  _ __  \n");

                    gotoxy(20, 4);
                    printf("|  _  | / _ \\ / _` || '_ \\ \n");

                    gotoxy(20, 5);
                    printf("| | | ||  __/| (_| || |_) |\n");

                    gotoxy(20, 6);
                    printf("\\_| |_/ \\___| \\__,_|| .__/ \n");

                    gotoxy(20, 7);
                    printf("                    | |    \n");

                    gotoxy(20, 8);
                    printf("                    |_|    \n");

                    int u;
                    gotoxy(15, 10);
                    printf("배열의 크기를 입력하세요: ");
                    scanf_s("%d", &u);

                    if (u <= 0) {
                        printf("유효하지 않은 크기입니다. 양수를 입력하세요.\n");
                        break;
                    }

                    int* heapArr = (int*)malloc(u * sizeof(int));
                    if (heapArr == NULL) {
                        printf("메모리 할당 실패\n");
                        break;
                    }
                    system("cls");

                    printf("배열의 요소를 입력하세요:\n");
                    for (int i = 0; i < u; i++) {
                        printf("heapArr[%d]: ", i);
                        scanf_s("%d", &heapArr[i]);
                    }

                    system("cls");

                    printf("사용자가 입력한 배열은: \n\t\t");
                    for (int i = 0; i < u; i++) {
                        printf("%d ", heapArr[i]);
                    }
                    printf("\n");

                    heap_sort(heapArr, u);

                    printf("힙 정렬 결과:\n");
                    for (int i = 0; i < u; i++) {
                        printf("%d ", heapArr[i]);
                    }
                    printf("\n");

                    free(heapArr); // 동적 메모리 해제

                    int goBack6; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(4, 25);
                        printf("1. 코드 및 설명 자세히 보기\n");
                        gotoxy(4, 26);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(4, 27);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack6);

                        switch (goBack6) {
                        case 1:
                            // 선택 다시하기 코드 추가
                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack6 != 2); // 목록으로 돌아가기 루프
                    break;
                case 7:
                    system("cls");

                    gotoxy(25, 1);
                    printf("______             _  _       \n");

                    gotoxy(25, 2);
                    printf("| ___ \\           | |(_)      \n");

                    gotoxy(25, 3);
                    printf("| |_/ /  __ _   __| | _ __  __\n");

                    gotoxy(25, 4);
                    printf("|    /  / _` | / _` || |\\ \\/ /\n");

                    gotoxy(25, 5);
                    printf("| |\\ \\ | (_| || (_| || | >  < \n");

                    gotoxy(25, 6);
                    printf("\\_| \\_| \\__,_| \\__,_||_|/_/\\_\\\n");

                    int t;
                    gotoxy(25, 8);
                    printf("배열의 크기를 입력하세요: ");
                    scanf_s("%d", &t);

                    if (t <= 0) {
                        printf("유효하지 않은 크기입니다. 양수를 입력하세요.\n");
                        break;
                    }

                    int* radixArr = (int*)malloc(t * sizeof(int));
                    if (radixArr == NULL) {
                        printf("메모리 할당 실패\n");
                        break;
                    }
                    system("cls");
                    printf("배열의 요소를 입력하세요:\n");
                    for (int i = 0; i < t; i++) {
                        printf("radixArr[%d]: ", i);
                        scanf_s("%d", &radixArr[i]);
                    }

                    system("cls");
                    printf("사용자가 입력한 배열은: \n\t\t");
                    for (int i = 0; i < t; i++) {
                        printf("%d ", radixArr[i]);
                    }

                    printf("\n");

                    printf("########### Sorting before ###########\n");
                    print_radix(radixArr, t);
                    radix_sort(radixArr, t);


                    printf("기수 정렬 결과:\n");
                    for (int i = 0; i < t; i++) {
                        printf("%d ", radixArr[i]);
                    }
                    printf("\n");

                    free(radixArr); // 동적 메모리 해제

                    int goBack7; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(4, 25);
                        printf("1. 코드 및 설명 자세히 보기\n");
                        gotoxy(4, 26);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(4, 27);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack7);

                        switch (goBack7) {
                        case 1:
                            // 선택 다시하기 코드 추가
                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack7 != 2); // 목록으로 돌아가기 루프
                    break;
                case 8:
                    system("cls");
                    printf("뒤로 갑니다.\n");
                    break;
                default:
                    printf("잘못된 옵션 선택입니다.\n");
                }
            } while (choice2 != 8); // 옵션 선택 메뉴 루프
            break;
        case 2:
            printf("그래프 목록입니다.\n");
            do {
                system("cls");
                // 첫 번째 줄
                gotoxy(25, 3);
                printf(" _____                      _     \n");

                // 두 번째 줄
                gotoxy(25, 4);
                printf("|  __ \\                    | |    \n");

                // 세 번째 줄
                gotoxy(25, 5);
                printf("| |  \\/ _ __   __ _  _ __  | |__  \n");

                // 네 번째 줄
                gotoxy(25, 6);
                printf("| | __ | '__| / _` || '_ \\ | '_ \\ \n");

                // 다섯 번째 줄
                gotoxy(25, 7);
                printf("| |_\\ \\| |   | (_| || |_) || | | |\n");

                // 여섯 번째 줄
                gotoxy(25, 8);
                printf(" \\____/|_|    \\__,_|| .__/ |_| |_|\n");

                gotoxy(25, 9);
                printf("                    | |           \n");

                gotoxy(25, 10);
                printf("                    |_|           \n");


                gotoxy(27, 13);
                printf("1. dfs\n");
                gotoxy(28, 14);
                printf("2. bfs\n");
                gotoxy(29, 15);
                printf("3. 프림\n");
                gotoxy(30, 16);
                printf("4. 크루스칼\n");
                gotoxy(31, 17);
                printf("5. 위상정렬");
                gotoxy(32, 18);
                printf("6. 뒤로 가기");

                gotoxy(30, 21);
                printf("■원하는 옵션을 선택하세요:");
                scanf_s("%d", &choice2);

                switch (choice2) {
                case 1:

                    system("cls");
                    gotoxy(5, 2);
                    printf("______               _    _             ______  _             _     _____                           _     ");
                    gotoxy(5, 3);
                    printf("|  _  \\             | |  | |            |  ___|(_)           | |   /  ___|                         | |    ");
                    gotoxy(5, 4);
                    printf("| | | |  ___  _ __  | |_ | |__   ______ | |_    _  _ __  ___ | |_  \\ `--.   ___   __ _  _ __   ___ | |__  ");
                    gotoxy(5, 5);
                    printf("| | | | / _ \\| '_ \\ | __|| '_ \\ |______||  _|  | || '__|/ __|| __|  `--. \\ / _ \\ / _` || '__| / __|| '_ \\ ");
                    gotoxy(5, 6);
                    printf("| |/ / |  __/| |_) || |_ | | | |        | |    | || |   \\__ \\| |_  /\\__/ /|  __/| (_| || |   | (__ | | | |");
                    gotoxy(5, 7);
                    printf("|___/   \\___|| .__/ \\ __||_| |_|        \\_|    |_||_|   |___/ \\__| \\____/  \\___| \\__,_||_|    \\___||_| |_|");
                    gotoxy(5, 8);
                    printf("             | |                                                                                          ");
                    gotoxy(5, 9);
                    printf("             |_|                                                                                          ");


                    int d1, d2;
                    int user;

                    gotoxy(55, 20);
                    printf("예시를 보여드리겠습니다.");
                    gotoxy(55, 21);
                    printf("정점이 몇 개로 설정하시겠나요? : 5");
                    gotoxy(55, 22);
                    printf("간선을 몇 개로 설정하시겠나요? : 4");
                    gotoxy(55, 23);
                    printf("1 2");
                    gotoxy(55, 24);
                    printf("1 3");
                    gotoxy(55, 25);
                    printf("2 4");
                    gotoxy(55, 26);
                    printf("3 5");

                    gotoxy(5, 12);
                    printf("정점이 몇 개로 설정하시겠나요? : ");
                    scanf_s("%d", &np);
                    gotoxy(5, 13);
                    printf("간선을 몇 개로 설정하시겠나요? : ");
                    scanf_s("%d", &nw);

                    gotoxy(55, 28);
                    printf("이해하셨다면 1번을 입력해주세요: ");
                    scanf_s("%d", &user);
                    system("cls");

                    gotoxy(55, 20);
                    printf("예시를 보여드리겠습니다.");
                    gotoxy(55, 21);
                    printf("정점이 몇 개로 설정하시겠나요? : 5");
                    gotoxy(55, 22);
                    printf("간선을 몇 개로 설정하시겠나요? : 4");
                    gotoxy(55, 23);
                    printf("1 2");
                    gotoxy(55, 24);
                    printf("1 3");
                    gotoxy(55, 25);
                    printf("2 4");
                    gotoxy(55, 26);
                    printf("3 5");


                    gotoxy(0, 0);
                    printf("정점 정점을 입력해주세요! ex) 1 2");

                    if (user == 1) {
                        printf("\n");
                        for (int i = 0; i < nw; i++) {
                            scanf_s("%d %d", &d1, &d2);
                            connection[d1][d2] = connection[d2][d1] = true;
                        }
                        dfs(1);
                    }
                    else
                        return "다시하세요!";

                    printf("\n");
                    int goBack1; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(4, 25);
                        printf("1. 코드 및 설명 자세히 보기\n");
                        gotoxy(4, 26);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(4, 27);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack1);

                        switch (goBack1) {
                        case 1:
                            // 선택 다시하기 코드 추가
                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack1 != 2); // 목록으로 돌아가기 루프
                    break;
                case 2:

                    system("cls");
                    gotoxy(3, 2);
                    printf("______                         _  _    _               __  _             _                                   _     ");
                    gotoxy(3, 3);
                    printf("| ___ \\                       | || |  | |             / _|(_)           | |                                 | |    ");
                    gotoxy(3, 4);
                    printf("| |_/ / _ __   ___   __ _   __| || |_ | |__   ______ | |_  _  _ __  ___ | |_   ___   ___   __ _  _ __   ___ | |__  ");
                    gotoxy(3, 5);
                    printf("| ___ \\| '__| / _ \\ / _` | / _` || __|| '_ \\ |______||  _|| || '__|/ __|| __| / __| / _ \\ / _` || '__| / __|| '_ \\ ");
                    gotoxy(3, 6);
                    printf("| |_/ /| |   |  __/| (_| || (_| || |_ | | | |        | |  | || |   \\__ \\| |_  \\__ \\|  __/| (_| || |   | (__ | | | |");
                    gotoxy(3, 7);
                    printf("\\____/ |_|    \\___| \\__,_| \\__,_| \\__||_| |_|        |_|  |_||_|   |___/ \\__| |___/ \\___| \\__,_||_|    \\___||_| |_|");

                    gotoxy(55, 20);
                    printf("예시를 보여드리겠습니다.");
                    gotoxy(55, 21);
                    printf("정점이 몇 개로 설정하시겠나요? : 5");
                    gotoxy(55, 22);
                    printf("간선을 몇 개로 설정하시겠나요? : 4");
                    gotoxy(55, 23);
                    printf("1 2");
                    gotoxy(55, 24);
                    printf("1 3");
                    gotoxy(55, 25);
                    printf("2 4");
                    gotoxy(55, 26);
                    printf("3 5");

                    int bfsD1, bfsD2;
                    gotoxy(3, 10);
                    printf("정점이 몇 개로 설정하시겠나요? : ");
                    scanf_s("%d", &bfsNp);
                    gotoxy(3, 11);
                    printf("간선을 몇 개로 설정하시겠나요? : ");
                    scanf_s("%d", &bfsNw);

                    printf("\n");

                    for (int i = 0; i < bfsNw; i++) {
                        scanf_s("%d %d", &bfsD1, &bfsD2);
                        bfsConnection[bfsD1][bfsD2] = bfsConnection[bfsD2][bfsD1] = true;
                    }

                    bfsTraverse(1);


                    printf("\n");
                    int goBack2; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(4, 25);
                        printf("1. 코드 및 설명 자세히 보기\n");
                        gotoxy(4, 26);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(4, 27);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack2);

                        switch (goBack2) {
                        case 1:
                            // 선택 다시하기 코드 추가
                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack2 != 2); // 목록으로 돌아가기 루프
                    break;
                case 3:

                    system("cls");
                    gotoxy(7, 2);
                    printf("______        _             _         ___   _                      _  _    _                ");
                    gotoxy(7, 3);
                    printf("| ___ \\      (_)           ( )       / _ \\ | |                    (_)| |  | |               ");
                    gotoxy(7, 4);
                    printf("| |_/ / _ __  _  _ __ ___  |/  ___  / /_\\ \\| |  __ _   ___   _ __  _ | |_ | |__   _ __ ___  ");
                    gotoxy(7, 5);
                    printf("|  __/ | '__|| || '_ ` _ \\    / __| |  _  || | / _` | / _ \\ | '__|| || __|| '_ \\ | '_ ` _ \\ ");
                    gotoxy(7, 6);
                    printf("| |    | |   | || | | | | |   \\__ \\ | | | || || (_| || (_) || |   | || |_ | | | || | | | | |");
                    gotoxy(7, 7);
                    printf("\\_|    |_|   |_||_| |_| |_|   |___/ \\_| |_/|_| \\__, | \\___/ |_|   |_| \\__||_| |_||_| |_| |_|");
                    gotoxy(7, 8);
                    printf("                                                __/ |                                       ");
                    gotoxy(7, 9);
                    printf("                                               |___/                                        ");

                    /* Integer */
                    int N = 0, M = 0; /* N - 정점의 개수, M - 간선의 개수 */
                    int Temp[3] = { 0, 0, 0 }; /* 입력 임시 변수 */
                    int ii, jj, count;


                    gotoxy(3, 10);
                    /* 정점 개수 입력 */
                    printf("정점 개수 : ");
                    scanf_s("%d", &N);
                    /* 간선 개수 입력 */
                    gotoxy(3, 11);
                    printf("간선 개수 : ");
                    scanf_s("%d", &M);

                    system("cls");

                    /* 정점 배열 초기화 */
                    for (ii = 1; ii <= N; ii++)
                    {
                        for (jj = 1; jj <= M; jj++) { prim_adj_mat[ii][jj] = primINF; }
                        prim_adj_mat[ii][ii] = 0;
                    }

                    /* 정점과 간선의 가중치 입력받는 구문 */
                    for (count = 0; count < M; count++)
                    {
                        /* Temp[0] = 정점, Temp[1] = 간선, Temp[2] = 가중치 */
                        printf("정점 간선 가중치(a b c) : ");
                        scanf_s("%d %d %d", &Temp[0], &Temp[1], &Temp[2]);
                        prim_adj_mat[Temp[0]][Temp[1]] = prim_adj_mat[Temp[1]][Temp[0]] = Temp[2];
                    }

                    /* Prim Algorithm 출력 */
                    printf("%d\n", prim(1, N));



                    printf("\n");
                    int goBack3; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(4, 25);
                        printf("1. 코드 및 설명 자세히 보기\n");
                        gotoxy(4, 26);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(4, 27);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack3);

                        switch (goBack3) {
                        case 1:
                            // 선택 다시하기 코드 추가
                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack3 != 2); // 목록으로 돌아가기 루프
                    break;
                case 4:

                    system("cls");
                    gotoxy(5, 2);
                    printf(" _   __                   _            _    ___   _                      _  _    _                ");

                    gotoxy(5, 3);
                    printf("| | / /                  | |          | |  / _ \\ | |                    (_)| |  | |               ");

                    gotoxy(5, 4);
                    printf("| |/ /  _ __  _   _  ___ | | __  __ _ | | / /_\\ \\| |  __ _   ___   _ __  _ | |_ | |__   _ __ ___  ");

                    gotoxy(5, 5);
                    printf("|    \\ | '__|| | | |/ __|| |/ / / _` || | |  _  || | / _` | / _ \\ | '__|| || __|| '_ \\ | '_ ` _ \\ ");

                    gotoxy(5, 6);
                    printf("| |\\  \\| |   | |_| |\\__ \\|   < | (_| || | | | | || || (_| || (_) || |   | || |_ | | | || | | | | |");

                    gotoxy(5, 7);
                    printf("\\_| \\_/|_|    \\__,_||___/|_|\\_\\ \\__,_||_| \\_| |_/|_| \\__, | \\___/ |_|   |_| \\__||_| |_||_| |_| |_|");

                    gotoxy(5, 8);
                    printf("                                                      __/ |                                       ");

                    gotoxy(5, 9);
                    printf("                                                     |___/                                        ");

                    system("cls");

                    int graph[9][9] = {                 // input_graph.pptx에 따른 비용인접행렬.
                 {0, 4, 0, 0, 0, 0, 0, 8, 0},
                 {4, 0, 8, 0, 0, 0, 0, 11, 0},
                 {0, 8, 0, 7, 0, 4, 0, 0, 2},
                 {0, 0, 7, 0, 9, 14, 0, 0, 0},
                 {0, 0, 0, 9, 0, 10, 0, 0, 0},
                 { 0, 0, 4, 14, 10, 0, 2, 0, 0},
                 { 0, 0, 0, 0, 0, 2, 0, 1, 6},
                 { 8, 11, 0, 0, 0, 0, 0, 0, 7},
                 { 0, 0, 2, 0, 0, 0, 6, 7, 0 },
                    };

                    printf("{\n");
                    printf("    {0, 4, 0, 0, 0, 0, 0, 8, 0},\n");
                    printf("    {4, 0, 8, 0, 0, 0, 0, 11, 0},\n");
                    printf("    {0, 8, 0, 7, 0, 4, 0, 0, 2},\n");
                    printf("    {0, 0, 7, 0, 9, 14, 0, 0, 0},\n");
                    printf("    {0, 0, 0, 9, 0, 10, 0, 0, 0},\n");
                    printf("    {0, 0, 4, 14, 10, 0, 2, 0, 0},\n");
                    printf("    {0, 0, 0, 0, 0, 2, 0, 1, 6},\n");
                    printf("    {8, 11, 0, 0, 0, 0, 0, 0, 7},\n");
                    printf("    {0, 0, 2, 0, 0, 0, 6, 7, 0},\n");
                    printf("};\n");

                    kruskal(graph);
                    // 보고 수정하기
                    // https://call203.tistory.com/10

                    printf("\n");
                    int goBack4; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(30, 25);
                        printf("1. 코드 및 설명 자세히 보기\n");
                        gotoxy(30, 26);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(30, 27);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack4);

                        switch (goBack4) {
                        case 1:
                            // 선택 다시하기 코드 추가
                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack4 != 2); // 목록으로 돌아가기 루프
                    break;
                case 5:
                    system("cls");
                    gotoxy(4, 0); printf(" _                         _                _               _                     _    _               ");
                    gotoxy(4, 1); printf("| |                       | |              (_)             | |                   | |  (_)              ");
                    gotoxy(4, 2); printf("| |_   ___   _ __    ___  | |  ___    __ _  _   ___   __ _ | |  ___   ___   _ __ | |_  _  _ __    __ _ ");
                    gotoxy(4, 3); printf("| __| / _ \\ | '_ \\  / _ \\ | | / _ \\  / _` || | / __| / _` || | / __| / _ \\ | '__|| __|| || '_ \\  / _` |");
                    gotoxy(4, 4); printf("| |_ | (_) || |_) || (_) || || (_) || (_| || || (__ | (_| || | \\__ \\| (_) || |   | |_ | || | | || (_| |");
                    gotoxy(4, 5); printf(" \\__| \\___/ | .__/  \\___/ |_| \\___/  \\__, ||_| \\___| \\__,_||_| |___/ \\___/ |_|    \\__||_||_| |_| \\__, |");
                    gotoxy(4, 6); printf("            | |                       __/ |                                                       __/ |");
                    gotoxy(4, 7); printf("            |_|                      |___/                                                       |___/ ");
                    printf("\n\n");

                    data* topologyarr[TSSIZE] = { NULL };  // data 구조체 포인터 저장 배열
                    int result[TSSIZE];  // 수행 결과 저장을 위한 스택

                    /* data 입력 */
                    int n, m;

                    scanf_s("%d %d", &n, &m);  // 학생수, 비교 횟수 입력
                    for (int i = 0; i < m; i++)
                    {
                        int index, x;  // 상위노드, 하위(연결)노드 임시저장
                        scanf_s("%d %d", &index, &x);
                        create_data(topologyarr, index, x);
                    }

                    /* 데이터 검증을 위한 count (전체 노드 수만큼 result에 값이 담겨야 함)*/
                    int topologycount = 0;
                    for (int i = 0; i < TSSIZE; i++)
                        if (topologyarr[i] != NULL)
                            topologycount++;

                    /* 위상 정렬 수행 */
                    if (topology_sort(topologyarr, result, topologycount) == 1)
                    {
                        puts("정렬 실패, 데이터가 잘못되었습니다");
                    }

                    /* 전체 리스트 출력 */
                    print_all(topologyarr, result, topologycount);

                    printf("\n");
                    int goBack5; // 목록으로 돌아가는 플래그
                    do {
                        gotoxy(30, 25);
                        printf("1. 코드 및 설명 자세히 보기\n");
                        gotoxy(30, 26);
                        printf("2. 목록으로 돌아가기\n");
                        gotoxy(30, 27);
                        printf("원하는 옵션을 선택하세요: ");
                        scanf_s("%d", &goBack5);

                        switch (goBack5) {
                        case 1:
                            // 선택 다시하기 코드 추가
                            break;
                        case 2:
                            system("cls");
                            // 목록으로 돌아가기 코드 추가
                            break;
                        default:
                            printf("잘못된 옵션 선택입니다.\n");
                        }
                    } while (goBack5 != 2); // 목록으로 돌아가기 루프
                    break;
                case 6:
                    system("cls");
                    printf("뒤로 갑니다.\n");
                    break;
                default:
                    printf("잘못된 옵션 선택입니다.\n");
                }
            } while (choice2 != 6);
            break;
        case 3:

            printf("프로그램을 종료합니다.\n");
            break;
        default:
            printf("잘못된 메뉴 선택입니다.\n");
        }
    } while (choice1 != 3); // 메인 메뉴 루프
}
